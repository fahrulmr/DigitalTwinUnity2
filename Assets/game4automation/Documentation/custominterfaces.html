<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>gam4automation DOC - custom interfaces</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.0.0/normalize.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,300,700" rel="stylesheet" type="text/css">
  <link href="style/docs.css" rel="stylesheet">
</head>
<body>
  <div class="menu">
    <div class="logo">
      Content
    </div>
    <nav class="menu-nav">
      
        <ul class="nav">
          <span>Preparation</span>
          <ul class="nav">
            
              <li>
                <a href="installation.html">Installation</a>
              </li>
            
              <li>
                <a href="releasenotes.html">Release Notes</a>
              </li>
            
          </ul>
        </ul>
      
        <ul class="nav">
          <span>Basics</span>
          <ul class="nav">
            
              <li>
                <a href="userinterface.html">User Interface</a>
              </li>
            
              <li>
                <a href="runtimeui.html">Runtime UI</a>
              </li>
            
              <li>
                <a href="folderstructure.html">structure</a>
              </li>
            
              <li>
                <a href="importexport.html">Importing and exporting</a>
              </li>
            
              <li>
                <a href="demomodel.html">Demo Model</a>
              </li>
            
              <li>
                <a href="tutorial.html">Tutorial</a>
              </li>
            
              <li>
                <a href="physics.html">Physics</a>
              </li>
            
              <li>
                <a href="import3ddata.html">CAD import</a>
              </li>
            
              <li>
                <a href="cadlink.html">CADLink</a>
              </li>
            
              <li>
                <a href="pixyz.html">Import with PIXZ</a>
              </li>
            
              <li>
                <a href="cadupdater.html">CADUpdater</a>
              </li>
            
              <li>
                <a href="LargeAssemblies.html">Large Assemblies</a>
              </li>
            
              <li>
                <a href="SelectionWindow.html">Selection Window</a>
              </li>
            
              <li>
                <a href="CADChecker.html">CAD Checker</a>
              </li>
            
              <li>
                <a href="parts4cad.html">parts4cad</a>
              </li>
            
          </ul>
        </ul>
      
        <ul class="nav">
          <span>Components</span>
          <ul class="nav">
            
              <li>
                <a href="game4automation.html">Game4Automation</a>
              </li>
            
              <li>
                <a href="source.html">Source</a>
              </li>
            
              <li>
                <a href="sink.html">Sink</a>
              </li>
            
              <li>
                <a href="mu.html">MU</a>
              </li>
            
              <li>
                <a href="partchanger.html">PartChanger</a>
              </li>
            
              <li>
                <a href="motionaxis.html">Motions</a>
              </li>
            
              <li>
                <a href="group.html">Group</a>
              </li>
            
              <li>
                <a href="kinematic.html">Kinematics</a>
              </li>
            
              <li>
                <a href="drive.html">Drive</a>
              </li>
            
              <li>
                <a href="CAM.html">CAM</a>
              </li>
            
              <li>
                <a href="transportsurface.html">Transport Surface</a>
              </li>
            
              <li>
                <a href="drivebehaviour.html">Drive Behavior</a>
              </li>
            
              <li>
                <a href="chain.html">Chain</a>
              </li>
            
              <li>
                <a href="chainelement.html">Chain element</a>
              </li>
            
              <li>
                <a href="sensor.html">Sensor</a>
              </li>
            
              <li>
                <a href="sensor.html">Sensor</a>
              </li>
            
              <li>
                <a href="grip.html">Grip</a>
              </li>
            
              <li>
                <a href="lamp.html">Lamp</a>
              </li>
            
              <li>
                <a href="uicomponents.html">UI components</a>
              </li>
            
              <li>
                <a href="plc.html">PLC</a>
              </li>
            
              <li>
                <a href="interface.html">Automation Interfaces</a>
              </li>
            
              <li>
                <a href="s7tcpip.html">S7-TCPIP</a>
              </li>
            
              <li>
                <a href="twincat.html">TwinCAT</a>
              </li>
            
              <li>
                <a href="sharedmemory.html">Shared Memory</a>
              </li>
            
              <li>
                <a href="plcsimadvanced.html">PLCSIM Advanced</a>
              </li>
            
              <li>
                <a href="opcua.html">OPC UA</a>
              </li>
            
              <li>
                <a href="robodk.html">RoboDK</a>
              </li>
            
              <li>
                <a href="modbus.html">Modbus</a>
              </li>
            
              <li>
                <a href="">Custom interfaces</a>
              </li>
            
              <li>
                <a href="playmaker.html">Visual Scripting</a>
              </li>
            
          </ul>
        </ul>
      
        <ul class="nav">
          <span>Advanced</span>
          <ul class="nav">
            
              <li>
                <a href="combilerdefines.html">Compiler Defines</a>
              </li>
            
              <li>
                <a href="assemblydefinitions.html">Assembly Defintions</a>
              </li>
            
              <li>
                <a href="yourown.html">Starting your own Project</a>
              </li>
            
          </ul>
        </ul>
      
    </nav>
    <a class="footer" href="https://game4automation.com">
      Game4Automation
    </a>
  </div>
  <div class="page">
   
    <div class="page-content">
	<p>This is the offline version of the documentation. We recommend you to use the <a href="https://game4automation.com/documentation/current/index.html">online documentation.</a></p>
 <h1 id="Custom-Interfaces"><a href="#Custom-Interfaces" class="headerlink" title="Custom Interfaces"></a>Custom Interfaces</h1><p>Game4Automation is open and you could implement your custom interfaces to external software and hardware. Usually, you are using C# interface API of the external software.</p>
<p>All interface scripts in Game4Automation inherit from the base class InterfaceBaseClass.</p>
<p>Depending on the interface type you are developing your new interface should inherit directly from one of these classes (all of them inherit from InterfaceBaseClass)</p>
<h2 id="InterfaceBaseClass"><a href="#InterfaceBaseClass" class="headerlink" title="InterfaceBaseClass"></a>InterfaceBaseClass</h2><p>For interface with a fast API data exchange or a small amount of data where you don’t need multithreading because of performance and possible long data exchange cycle times.</p>
<h2 id="InterfaceThreadedBaseClass"><a href="#InterfaceThreadedBaseClass" class="headerlink" title="InterfaceThreadedBaseClass"></a>InterfaceThreadedBaseClass</h2><p>For multi-threaded interfaces where the data exchange with the external application is running in a parallel thread.</p>
<p>##InterfaceSHMBaseclass</p>
<p>For interfaces using shared memory to communicate with the external application. You can define your own shared memory data structure by writing your own interface.</p>
<h1 id="Methods-each-custom-interface-must-implement"><a href="#Methods-each-custom-interface-must-implement" class="headerlink" title="Methods each custom interface must implement"></a>Methods each custom interface must implement</h1><h2 id="OpenInterface"><a href="#OpenInterface" class="headerlink" title="OpenInterface()"></a>OpenInterface()</h2><p>A method that will be called when the interface should connect. The base class is calling this in <em>OnAwake</em>. When the connection is successful <em>OnConnected()</em> must be called. If the connection is not successful <em>OnDisconnected()</em> should be called and an attempt to connect should be made later on.</p>
<p>After opening the interface this method should also update the signal list with this method:<br><em>UpdateInterfaceSignals(ref NumberInputs, ref NumberOutputs);</em></p>
<p>This method will parse the underlying objects and create a pulic list of Interface Signals:<br>public List<interfacesignal> InterfaceSignals</interfacesignal></p>
<p>You should use this list of interface signals later on in your update method for the signals.</p>
<h2 id="CloseInterface"><a href="#CloseInterface" class="headerlink" title="CloseInterface()"></a>CloseInterface()</h2><p>A method that will be called when the interface should connect. The base class is calling this in OnDestroy.</p>
<h2 id="Awake"><a href="#Awake" class="headerlink" title="Awake()"></a>Awake()</h2><p>This standard method is called before OpenInterface. Use this method for initializing your variables or setting your external references. If you use Awake in your Interface implementation you must call inside your Awake() base.Awake() so that the Game4AutomationBehavior Awake is also called. Please don’t connect the Interface in your Awake method and please don’t call OpenInterface yourself in the Awake method.</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update()"></a>Update()</h2><p>An Update Method should implement an automatically reconnecting in a certain period for example like this.</p>
<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (reconnecting &amp;&amp; (Time.time-_lastreconnect)&gt;<span class="number">1</span>)</span><br><span class="line">             OpenInterface();</span><br><span class="line">         <span class="keyword">if</span> (IsConnected)</span><br><span class="line">             UpdateSignals(); <span class="comment">// only if signals are updated on the main thread</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>    
<p>Only for non-threaded interfaces, you should also implement in this method the Update of the Signals (like UpdateSignals()) in the example above.</p>
<h2 id="Importing-Signals"><a href="#Importing-Signals" class="headerlink" title="Importing Signals"></a>Importing Signals</h2><p>Each interface should implement a method and a button in the inspector to import the signals. This method should parse the signals on the interface and create (if not already there) new Signal objects as sub-objects under the interface.</p>
<p>To create a signal you should follow the following steps:</p>
<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var signal = <span class="keyword">new</span> InterfaceSignal();</span><br><span class="line">signal.Name = <span class="string">"the symbold name you received from the interface"</span></span><br><span class="line">signal.SymbolName = adsSymbol.Name;</span><br><span class="line">signal.Direction = InterfaceSignal.DIRECTION.OUTPUT; <span class="comment">// or InterfaceSignal.DIRECTION.INPUT</span></span><br><span class="line">signal.OriginDataType = <span class="string">"original data type"</span>; <span class="comment">// original data type</span></span><br><span class="line">signal.Type = InterfaceSignal.TYPE.INT <span class="comment">// or other signal types depending on your interface signal</span></span><br><span class="line">AddSignal(signal); <span class="comment">// this will add a new signal object under the interface</span></span><br></pre></td></tr></table></figure>                
<h1 id="Updating-the-signal-values-during-simulation"><a href="#Updating-the-signal-values-during-simulation" class="headerlink" title="Updating the signal values during simulation"></a>Updating the signal values during simulation</h1><p>How to update the signals for the inputs and outputs depends very much on your interface type you are developing. For example, if your interface is multi-threaded or if it is possible to observe (to receive an event) if the output values changed or not.</p>
<p>If available you should always prefer to subscribe with your interface API for changes of the values. Polling all variables on each cycle is usually not the best performing method, but it depends on the methods your selected interface API is providing. If the only way for receiving the values is cyclic polling you should implement this cyclic polling in a parallel thread by using the  <em>InterfaceThreadedBaseClass</em>,</p>
<p>For PLCInputs you could subscribe for data changes on the signals like that:<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">if</span> (signal.Direction == InterfaceSignal.DIRECTION.INPUT)</span><br><span class="line">&#123;</span><br><span class="line">    signal.Signal.SignalChanged += OnPLCInputSignalChanged;</span><br><span class="line">&#125;</span><br><span class="line">			</span><br></pre></td></tr></table></figure>        </p>
<p>This will call the Method <em>OnPLCInputSignalChanged</em> each time Game4Automation changes the signals and you can take care in this method to send the new values with the use of your  interface api.</p>
<p>If you want to make a loop over all interface signals you can use the following blueprint. The list of interface signals must be created during connecting to the interface - see above :<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   foreach (var signal in InterfaceSignals)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (signal.Direction == InterfaceSignal.DIRECTION.OUTPUT)</span><br><span class="line">                &#123;</span><br><span class="line">	..... <span class="keyword">and</span> so on</span><br></pre></td></tr></table></figure>                            </p>
<h1 id="Special-methods-for-multi-threaded-interfaces"><a href="#Special-methods-for-multi-threaded-interfaces" class="headerlink" title="Special methods for multi-threaded interfaces"></a>Special methods for multi-threaded interfaces</h1><p>If you inherit from <em>InterfaceThreadedBaseClass</em> you need to call <em>base.OpenInterface()</em> in your <em>OpenInterface</em> method. This will start the multi threaded communication thread:<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">OpenInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       .. what you need to <span class="keyword">do</span> <span class="keyword">for</span> opening the interface</span><br><span class="line">       base.OpenInterface();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>                </p>
<p>You need to do the same in your <em>CloseInterface</em> method:<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">CloseInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          .... what you need to <span class="keyword">do</span> to close the interface..</span><br><span class="line"></span><br><span class="line">          base.CloseInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        </p>
<p>By calling <em>base.CloseInterface()</em> the communication thread will be stopped.</p>
<h2 id="protected-override-void-CommunicationThreadUpdate"><a href="#protected-override-void-CommunicationThreadUpdate" class="headerlink" title="protected override void CommunicationThreadUpdate()"></a>protected override void CommunicationThreadUpdate()</h2><p>This method will be called automatically by the <em>InterfaceThreadedBaseClass</em>. You should implement here everything that you need for reading and writing the inputs and outputs.</p>
<p>It is very important, that you can not write directly to Unity object in a parallel thread. This means that you should use a data structure to synchronize between the parallel thread and the Unity main task. Your thread will write into this data and in Unity’s update method you can take this data transfer the information to Unity objects. You can use the <em>InterfaceSignal</em> class or your own custom class which inherits from InterfaceSignal to do this. You can take a look into the S7-Interface which is implemented multi-threaded to have a blueprint for your own multi-threaded solution.</p>
<p>To prevent collissions between the main unity thread and your communication thread you should use this statement to lock your data structure im your communication thread:<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock (InterfaceSignals)</span><br><span class="line">           &#123;.....</span><br></pre></td></tr></table></figure>    </p>
<h2 id="protected-override-void-CommunicationThreadUpdate-1"><a href="#protected-override-void-CommunicationThreadUpdate-1" class="headerlink" title="protected override void CommunicationThreadUpdate()"></a>protected override void CommunicationThreadUpdate()</h2><p>This method will be called automatically by the <em>InterfaceThreadedBaseClass</em>. You should implement here everything that you need for reading and writing the inputs and outputs.</p>
<h1 id="Methods-each-custom-interface-should-call"><a href="#Methods-each-custom-interface-should-call" class="headerlink" title="Methods each custom interface should call"></a>Methods each custom interface should call</h1><h2 id="OnConnected"><a href="#OnConnected" class="headerlink" title="OnConnected()"></a>OnConnected()</h2><p>A method in the base class which is called each time the interface is connected successfully. This could be on simulation start or when a reconnection attempt is successful. By calling this method the signals and interface will be automatically shown as connected and the Connect Button in the runtime UI will become greed (it is white when not connected). The <em>IsConnected</em> boolean property will get true.</p>
<h2 id="OnDisconnected"><a href="#OnDisconnected" class="headerlink" title="OnDisconnected()"></a>OnDisconnected()</h2><p>A method in the base class that is called each time the interface is disconnected. This could be at the end of simulation or when a communication interruption is recognized. By calling this method the signals and interface will be automatically shown as disconnected and the Connect Button in the runtime UI will become white (it is green when connected). The IsConnected boolean property will get false.</p>

	  <br>

	  <p><font size="1">&copy; 2019 in2Sight GmbH <a href="https://game4automation.com"> https://game4automation.com </a> - All rights reserved. No part of this publication may be reproduced, distributed, or transmitted in any form or by any means, including printing, saving, photocopying, recording, or other electronic or mechanical methods, without the prior written permission of the publisher.</font></p>
    </div>
	
  </div>
  <div class="switch-page">
    
    
  </div>
</body>
</html>